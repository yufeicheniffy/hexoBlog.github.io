<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://yufeicheniffy.github.io/hexoBlog.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/hexoBlog.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/hexoBlog.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexoBlog.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexoBlog.github.io/">Home</a>
        
          <a class="main-nav-link" href="/hexoBlog.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/hexoBlog.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yufeicheniffy.github.io/hexoBlog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoBlog.github.io/2019/07/08/JS数据类型/" class="article-date">
  <time datetime="2019-07-08T20:43:40.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoBlog.github.io/2019/07/08/JS数据类型/">JS数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: JS数据类型<br>date: 2019-07-08 21:43:40</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript 作为一门动态语言，其数据类型还是比较特别的，其中坑点不少，列出以备自己随时查看。</p>
<h2 id="1-JavaScript的基本数据类型"><a href="#1-JavaScript的基本数据类型" class="headerlink" title="1. JavaScript的基本数据类型"></a>1. JavaScript的基本数据类型</h2><p>JavaScript 的基本数据类型目前包括七类： Number, String, Boolean, Undefined, Null, Symbol(ES6新增) 及 Object。 需要注意的是，JS支持的数据类型一直在扩充，比如新加入的<a href="https://www.w3.org/community/webassembly/" target="_blank" rel="noopener">WebAssembly</a>， <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays" target="_blank" rel="noopener">typed arrays</a> 。 </p>
<h4 id="1-1-Number"><a href="#1-1-Number" class="headerlink" title="1.1. Number"></a>1.1. Number</h4><p>Number就是JavaScript中的数值类型。与其他语言不同， JS的数值类型一开始只有Number一种。 Number 就是IEEE754 所规定的 64-bit floating number。 所以Number并不区分整形与浮点型，一律用64位浮点数存储数值。</p>
<h5 id="1-1-1-IEEE754"><a href="#1-1-1-IEEE754" class="headerlink" title="1.1.1 IEEE754"></a>1.1.1 IEEE754</h5><p>IEEE754 是一个浮点数标准，规定了浮点数应该如何存储。</p>
<p><img src="img/618px-IEEE_754_Double_Floating_Point_Format.svg.png" alt="IEEE 754 Double Floating Point Format.svg"></p>
<p>图片转自<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="noopener">维基百科</a> </p>
<p>其中的64位浮点数由三个部分组成： Sign(1 bit)， Exponent(11bit)， Fraction(52)。 即符号位，指数位和有效数字位（小数位）。 符号位规定了正负。指数位规定了浮动范围，即可以在2^n 内浮动。n=2^11=2048。 有效数字为存储有效数字。 简单来说，IEEE754就是科学记数法的变种。 </p>
<p>具体来说，设真正的数值为T。 则T= <strong>(-1)^sign *(1.[fraction])*2^(exponent-offset)</strong> 。</p>
<p>T的符号由 <strong>(-1)^sign</strong> 决定，所以0为正1为负。</p>
<p>T的数值由 1.franction * 指数位 决定。这里引出两个有问题: 1. 为什么有一个“1.” 在小数部分前面?  2. offset 是什么？为什么要offset？</p>
<p>前面提到过，IEEE754的核心思想还是科学记数法，而且是二进制的科学计数法。先想想我们熟悉的十进制科学记数法，它把一个数表示成a与10的n次幂相乘的形式（1≤a&lt;10，n为整数）。a的范围是[1，10) 是因为只要超出这个范围，就应该更变n了。 例如 0.9=9<em>10^-1。 同理，二进制的科学计数法a的范围是[1，2) ，所以其个位数一定是1。 这个1称为”The leading one”，因为肯定存在而且肯定是1，所以这里直接省略将其存在计算机内来节约空间。offset就是指数偏移量，我们想要表示0.0001需要1\</em>10^-4。 但是我们的指数为是没有符号位的，它是一个无符号整数，只能表示正。所以IEEE通过引入一个默认的偏移量表表示负指数，这个偏移量是2^exponent-1即1023。所以我们真正表示的数的指数位由存在计算机中的exponent和偏移量决定。最后的fraction就是小数部分，它的大小决定了我们能够存储的有效数字的精度。</p>
<p>关于IEEE754和浮点数的存储还有很多值得注意的地方，我会在这篇文章中给出（占坑有空整理更新）。</p>
<p>由于JS使用浮点数的形式来表示整数，所以其整数的范围就是fraction能表示的范围，即+/- 2^53(加上leading one)。0有特殊的表示。</p>
<h5 id="1-1-2-Number支持进制"><a href="#1-1-2-Number支持进制" class="headerlink" title="1.1.2  Number支持进制"></a>1.1.2  Number支持进制</h5><p>Number是支持不同进制的，二进制由0b开头，八进制由0开头，十六进制由0x开头。</p>
<p>即 0x10===16===014===0b10000</p>
<p>JS中的进制转换可以通过parseInt()方法和toString()方法。 通过parseInt()转化为十进制再通过toString()转为其他进制。</p>
<p>例如 parseInt(‘0x10’,16).toString(2) //“10000”。需要注意的是，JS 将0x10直接认定为一个合法的数字，所以parseInt(0x10,16) 的结果是22 不是16。整个机制是 parseInt(0x10,16) -&gt; parseInt(16,16) -&gt; 22。 </p>
<h5 id="1-1-3-特殊的数字"><a href="#1-1-3-特殊的数字" class="headerlink" title="1.1.3 特殊的数字"></a>1.1.3 特殊的数字</h5><p>NaN infinity 正负零等，详见（占坑有空整理更新）。</p>
<h2 id="1-2-Boolean"><a href="#1-2-Boolean" class="headerlink" title="1.2. Boolean"></a>1.2. Boolean</h2><ul>
<li>boolean有两个值true/false ，区分大小写。 所以True和False 不是Boolean，可以作为标识符。</li>
</ul>
<h2 id="1-3-undefined-和-null"><a href="#1-3-undefined-和-null" class="headerlink" title="1.3. undefined 和 null"></a>1.3. undefined 和 null</h2><ul>
<li><p>undefined 表示空值， 一般用于变量已声明但是未赋值。已声明未赋值变量调用会得到undefined值。未声明变量调用报错。typeof() <strong>不能</strong> 用来判断变量是否声明，未声明变量也会返回undefined. ** 所以建议，总是在声明变量时赋值。**</p>
</li>
<li><p>null表示空对象，typeof() 返回 “object”。一般用于表示这个变量的值是对象，但是现在为空。</p>
</li>
</ul>
<h2 id="1-4-String"><a href="#1-4-String" class="headerlink" title="1.4. String"></a>1.4. String</h2><ul>
<li><p>同其他很多语言一样，字符串不可变。</p>
</li>
<li><p>字符串默认只能写在一行内，分成多行将会报错。长字符串必须分成多行，可以在每一行的尾部使用反斜杠。反斜杠还有三种特殊用法。\OOO \xHH \uHHHH 分别表示unicode字符。 O与H分别为八进制和十六进制数字。</p>
</li>
<li><p>UTF-16 有两种长度：<br>对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；65536个字符<br>对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。<a href="https://javascript.ruanyifeng.com/grammar/string.html" target="_blank" rel="noopener">阮一峰</a> </p>
</li>
<li><p>Base64</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。也可以用来防范爬虫。</p>
<ul>
<li><p>btoa()：任意值转为 Base64      编码</p>
</li>
<li><p>atob()：Base64      编码转为原来的值</p>
</li>
<li><ul>
<li>注意，这两个方法不适合非 ASCII 码的字符，会报错。要将非 ASCII 码字符转为 Base64       编码，必须中间插入一个转码环节，再使用这两个方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>encodeURIComponent(str)</p>
<ul>
<li>ecodeURIComponent(atob(str))<h2 id="1-5-Object"><a href="#1-5-Object" class="headerlink" title="1.5. Object"></a>1.5. Object</h2></li>
</ul>
</li>
<li><p>对象就是hash表</p>
</li>
<li><p>键名会被自动转成字符串</p>
</li>
<li><p>在声明时，如果不符合标识符原则，需要加上“”，否则可以不加</p>
</li>
<li><p>普通键值对就是属性，值是函数就是方法。</p>
</li>
<li><ul>
<li><p>属性可以动态创建（先声明后赋值）</p>
</li>
<li><p>属性的读取：</p>
</li>
<li><ul>
<li>.读取：属性自动变为字符串，即.后必须是属性名</li>
<li>[]读取：属性不加’’会被解释为变量</li>
<li>数值键名只能用[]，因为会被当成小数点</li>
</ul>
</li>
<li><p>delete</p>
</li>
<li><ul>
<li>delete只能删除自己的属性</li>
<li>只有该属性不能删除时才返回false</li>
<li>返回true时，如果该属性不是自身属性的（继承而来）,该属性依然存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>ECMAS Object基本方法:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>constructor</th>
<th>构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>hasownProperty</td>
<td></td>
</tr>
<tr>
<td>isPrototyprOf</td>
<td></td>
</tr>
<tr>
<td>propertyIsEnumerable</td>
<td></td>
</tr>
<tr>
<td>toLocaleString</td>
<td>宿主环境是否支持</td>
</tr>
<tr>
<td>toString</td>
<td></td>
</tr>
<tr>
<td>valueof</td>
<td></td>
</tr>
</tbody></table>
<p>注意： BOM 和 DOM 并不用遵守EMCAS</p>
<h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2. 类型转换"></a>2. 类型转换</h2><table>
<thead>
<tr>
<th></th>
<th>Number</th>
<th>String</th>
<th>Boolean</th>
<th>null</th>
<th>undefined</th>
<th>Object</th>
<th>symbol</th>
</tr>
</thead>
<tbody><tr>
<td>Numer</td>
<td>\</td>
<td>1,2,3</td>
<td>1,2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>String</td>
<td>1,2,3,4,5</td>
<td>\</td>
<td>1,2</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Boolean</td>
<td>1,4,5</td>
<td>1,2,3</td>
<td>\</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>null</td>
<td>1,4,5</td>
<td>2,3</td>
<td>1,2</td>
<td>\</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>undifined</td>
<td>1,4,5</td>
<td>2,3</td>
<td>1,2</td>
<td></td>
<td>\</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object</td>
<td>1,4,5</td>
<td>1,2,3</td>
<td>1,2</td>
<td></td>
<td></td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>symbol</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>\</td>
</tr>
</tbody></table>
<p>转化为字符串方法:</p>
<ol>
<li>tostring()null 和 undefined 不行 number 可以带参表示进制</li>
<li>String（）<br>有toString用toString。 null=”null” undefined=”undifined”</li>
<li>+ “”</li>
</ol>
<p>转化为Boolean方法：</p>
<ol>
<li>Boolean（）</li>
<li>！！x</li>
</ol>
<p>转化为Number（）方法：</p>
<ol>
<li>Number（） 类型转换</li>
<li>parseInt（） 整数，八进制不支持，要跟参数8</li>
<li>parseFloat（） 浮点数转换</li>
<li>x - 0</li>
<li>+ x</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yufeicheniffy.github.io/hexoBlog.github.io/2019/07/08/JS数据类型/" data-id="cjxuv736f0002p4p85dv89eig" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git常用命令与场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoBlog.github.io/2019/06/22/Git常用命令与场景/" class="article-date">
  <time datetime="2019-06-22T00:45:42.000Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoBlog.github.io/2019/06/22/Git常用命令与场景/">Git常用命令与场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git 目前已经是很知名的版本管理软件了，作为一名程序猿是必须知道的，但是自己在学习Git的过程中总是发现：命令太多，强行学习并没有什么用，而且日常使用中其实只会用到其中的<strong>一部分</strong>。在以后的工作中需要什么功能<strong>Google</strong>一下就好了。所以这篇文章会列出我常用的功能和相应场景，尽量满足覆盖日常工作内容。随时更新。</p>
<h1 id="面向的读者"><a href="#面向的读者" class="headerlink" title="面向的读者"></a>面向的读者</h1><p>对Git和Github有点了解，但是苦于命令的。<br>如果不了解，维基百科是个好地方：）</p>
<h1 id="在阅读前需要知道的：Git的分区"><a href="#在阅读前需要知道的：Git的分区" class="headerlink" title="在阅读前需要知道的：Git的分区"></a>在阅读前需要知道的：Git的分区</h1><p>Git中第一个需要了解是的Git的分区。<br><img src="https://upload-images.jianshu.io/upload_images/18267594-484cbc17eb1e4d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><em>图片转自：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a> 阮一峰的博客</em></p>
<h4 id="各分区的解释"><a href="#各分区的解释" class="headerlink" title="各分区的解释"></a>各分区的解释</h4><ul>
<li>Remote区<br>Remote区就是远程仓库，你和小伙伴们都能访问的地方，也是小伙伴获得你代码的地方。你最终的完成代码应该放到这里。位于<strong>网络上</strong>。</li>
<li>WorkSpace 区<br>你写代码的地方，位于你的<strong>本机</strong>。</li>
<li>Repository区<br>同样位于<strong>本机</strong>。按道理，只要有Remote区和WorkSpace区就能做到将自己的代码上传并且完成版本控制了。为什么中间要有一个Repository区?因为自己的代码往往是个草稿，需要经过多次修改，放入Repository区的才是成品。我们希望与Remote打交道时是深思熟虑后完整的程序，而不是带有很多BUG的你的第一次作品。 所以Repository也可以理解为<strong>待上传区</strong>。 </li>
</ul>
<p>故而我们可以这样理解三个区: </p>
<p>workspace:草稿 -&gt; Repository: 作品 -&gt; Remote：共享区</p>
<h1 id="第一步：创建这三个区"><a href="#第一步：创建这三个区" class="headerlink" title="第一步：创建这三个区"></a>第一步：创建这三个区</h1><p>有两种典型方法。</p>
<h4 id="1：先在网络上创建Reomte，再创建本地仓库"><a href="#1：先在网络上创建Reomte，再创建本地仓库" class="headerlink" title="1：先在网络上创建Reomte，再创建本地仓库."></a>1：先在网络上创建Reomte，再创建本地仓库.</h4><p>流程：去github创建远程仓库（readme+license），之后clone到本地即可。</p>
<h4 id="2：先创建本地仓库，在提交到远程仓库。"><a href="#2：先创建本地仓库，在提交到远程仓库。" class="headerlink" title="2：先创建本地仓库，在提交到远程仓库。"></a>2：先创建本地仓库，在提交到远程仓库。</h4><ol>
<li>git init ： 创建本地仓库</li>
<li>github创建空仓库。</li>
<li>git remote add ssh/http link</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yufeicheniffy.github.io/hexoBlog.github.io/2019/06/22/Git常用命令与场景/" data-id="cjxuv73690000p4p8kyi16qdr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http的报文和状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoBlog.github.io/2019/06/22/http的报文和状态码/" class="article-date">
  <time datetime="2019-06-22T00:00:34.000Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoBlog.github.io/2019/06/22/http的报文和状态码/">http的报文和状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTP作为一个应用层协议，了解了它的报文与状态码后就可以有基础的认识了。 日后可以随着工作逐渐深入。</p>
<h1 id="面向读者"><a href="#面向读者" class="headerlink" title="面向读者"></a>面向读者</h1><p>零基础想对HTTP有快速了解的。</p>
<p>#1. 什么是HTTP？<br>HTTP 即HyperText Transfer Protocol， 超文本传输协议。</p>
<ul>
<li>什么是HyperText？<blockquote>
<p><strong>超文本</strong>（英语：<strong>Hypertext</strong>）是一种可以显示在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%A1%AF%E7%A4%BA%E5%99%A8" title="计算机显示器" target="_blank" rel="noopener">计算机显示器</a>或其他<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E8%A8%AD%E5%82%99" title="电子设备" target="_blank" rel="noopener">电子设备</a>的文本，其中的文字包含有可以链接到其他字段或者文档的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E9%80%A3%E7%B5%90" title="超链接" target="_blank" rel="noopener">超链接</a>，允许从当前阅读位置直接切换到超链接所指向的文字<sup><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC#cite_note-1" target="_blank" rel="noopener">[1]</a></sup>。超文本文档通过超链接相互链接，超链接通常通过鼠标点击、按键设置或触摸屏来点阅。</p>
</blockquote>
</li>
<li>转自<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">维基百科</a>*</li>
</ul>
<p>简单来说，就是一种可以随时跳转的文本。而传输这种文本的协议，就是HTTP。 </p>
<ul>
<li>什么是协议?<blockquote>
<p><strong>通信协议</strong>（英语：<strong>Communications Protocol</strong>，也称<strong>传输协议</strong>）在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E4%BF%A1" title="电信" target="_blank" rel="noopener">电信</a>中是指在任何物理介质中允许两个或多个在<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F&action=edit&redlink=1" target="_blank" rel="noopener">传输系统</a>的终端之间传播<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF" title="信息" target="_blank" rel="noopener">信息</a>的系统标准，也是指计算机通信或网络设备的共同语言。<sup><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#cite_note-1" target="_blank" rel="noopener">[1]</a></sup>， 通信协议定义了<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1" title="通信" target="_blank" rel="noopener">通信</a>中的<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%AD%A6" title="语法学" target="_blank" rel="noopener">语法学</a>, <a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89%E5%AD%A6" title="语义学" target="_blank" rel="noopener">语义学</a>和<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5" title="同步" target="_blank" rel="noopener">同步</a>规则以及可能存在的<a href="https://zh.wikipedia.org/wiki/%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%BA%A0%E6%AD%A3" title="错误检测与纠正" target="_blank" rel="noopener">错误检测与纠正</a>。通信协议在<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6" title="硬件" target="_blank" rel="noopener">硬件</a>，<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件" target="_blank" rel="noopener">软件</a>或两者之间皆可实现<sup><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#cite_note-2" target="_blank" rel="noopener">[2]</a></sup></p>
</blockquote>
</li>
<li>转自<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">维基百科</a>*</li>
</ul>
<p>所以，我们理解一个协议，要从三个方面去理解。 语法（报文结构），语义（报文的意义）和同步规则，这三点即协议的三要素。</p>
<h1 id="2-报文的分类：请求报文与响应报文"><a href="#2-报文的分类：请求报文与响应报文" class="headerlink" title="2. 报文的分类：请求报文与响应报文"></a>2. 报文的分类：请求报文与响应报文</h1><p>HTTP作为传输协议，基本流程是客户端请求资源，随后服务端返回资源。故而报文可以分为请求报文与响应报文。<br><img src="https://upload-images.jianshu.io/upload_images/18267594-d2b4aaed25391326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="2-1-请求报文"><a href="#2-1-请求报文" class="headerlink" title="2.1 请求报文"></a>2.1 请求报文</h3><p>顾名思义，请求报文规定了客户端想服务端请求数据时需要提供的信息。<br>结构如下：<br>请求行：方法+URL+协议版本<br>请求首部：键值对<br>通用首都：键值对<br>空行：（CR+LF）<br>实体首部</p>
<p>请求首部与通用首部一般用来描述该请求或资源，比如指定HOST，表明请求所使用的软件等。</p>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18267594-5d8e2b02b02c023e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求报文"></p>
</blockquote>
<h5 id="2-1-1-方法"><a href="#2-1-1-方法" class="headerlink" title="2.1.1 方法"></a>2.1.1 方法</h5><p>方法即HTTP协议支持的方法，即客户端可以通过哪些命令来申请资源，不同的方法得到的资源可能是不一样的。一般来说，我们是为了获得HTML文件而使用HTTP。 但我们也可能使用HTTP去检查服务器状态。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>HEAD</td>
<td>与GET一样，但不返回实体。获取“关于该资源的信息”（元信息或称元数据）。这里结合响应报文去理解，响应报文有很多键值对去描述这个资源的情况，这里相当于就只要这些描述而不要资源本身。</td>
</tr>
<tr>
<td>POST</td>
<td>用于传输数据，向客户端发送信息，并获得相应资源。比如登陆时需要传输用户名密码。</td>
</tr>
<tr>
<td>PUT</td>
<td>上传文件，用于整体更新一个资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>更新部分资源，（由 <a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">[RFC 5789]</a> 指定的方法）</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
</tr>
<tr>
<td>TRACE</td>
<td>追踪路径，回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问服务器支持哪些HTTP方法</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求使用隧道协议连接</td>
</tr>
<tr>
<td>部分转自<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">维基百科</a></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-2-响应报文"><a href="#2-2-响应报文" class="headerlink" title="2.2 响应报文"></a>2.2 响应报文</h3><p>状态行: 协议+状态码+状态码解释<br>响应首部: 键值对<br>通用首部: 键值对<br>空行：（CR+LF）<br>实体首部</p>
<p>响应首部和通用首部一般用来描述资源或者服务器</p>
<blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/18267594-952cb71136d2d24b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应报文"></p>
</blockquote>
<h5 id="2-2-1-状态码"><a href="#2-2-1-状态码" class="headerlink" title="2.2.1 状态码"></a>2.2.1 状态码</h5><p>状态码能够快速理解这次请求的状态，是成功了还是失败了?还是有其他情况？<br>状态码主要分为5大类</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>解释</th>
<th>常见分类</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>这一类型的状态码，代表请求已被接受，需要继续处理。</td>
<td>100 ：Continue. 收到请求，客户端继续发送请求报文。</td>
</tr>
<tr>
<td>2XX</td>
<td>代表请求已成功被服务器<strong>接收、理解、并接受</strong>。</td>
<td>200 ：OK. 成功并且返回了所需的请求。<br>202: Accept. 接受了请求但尚未处理。<br>204：No content. 成功但没有实体返回。<br>206: 返回了请求的范围信息。</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向，表明URL已经被更改。这类状态码代表需要客户端采取进一步的操作才能完成请求。</td>
<td>300 Multiple Choices. 该URL有多个资源。<br><a href="https://zh.wikipedia.org/wiki/HTTP_301" title="HTTP 301" target="_blank" rel="noopener">301 Moved Permanently</a>该资源URL已经被永久改变，下次要用新的URL！<br><a href="https://zh.wikipedia.org/wiki/HTTP_302" title="HTTP 302" target="_blank" rel="noopener">302 Found</a>该资源URL临时改变了，可以更改请求方法访问。<br><a href="https://zh.wikipedia.org/wiki/HTTP_303" title="HTTP 303" target="_blank" rel="noopener">303 See Other</a>与302类似，建议使用GET方法<br>304 Not Modified: 已经在客户端缓存中了，别来找服务器要了：（<br><a href="https://zh.wikipedia.org/wiki/HTTP_307" title="HTTP 307" target="_blank" rel="noopener">307 Temporary Redirect</a>与302 303类似，不能改变请求方法。</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误。这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</td>
<td>400 Bad Request. 明显的错误，比如语法错误。<br>401 Unauthorized. 未验证。需要登录等。<br> 403 Forbidden. 禁止访问。服务器已经理解请求，但是拒绝执行它。<br>404 Not Found. 请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误。表示服务器无法完成明显有效的请求。</td>
<td>500 Internal Server Error. 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。<br> 501 Not Implemented. 服务器不支持当前请求所需要的某个功能。<br> 502 Bad Gateway. 作为<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" title="网关" target="_blank" rel="noopener">网关</a>或者<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" title="代理服务器" target="_blank" rel="noopener">代理</a>工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br> 503 Service Unavailable 由于临时的服务器维护或者<a href="https://zh.wikipedia.org/wiki/%E9%81%8E%E8%BC%89" title="重载" target="_blank" rel="noopener">过载</a>，服务器当前无法处理请求。</td>
</tr>
<tr>
<td>部分转自<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">维基百科</a></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yufeicheniffy.github.io/hexoBlog.github.io/2019/06/22/http的报文和状态码/" data-id="cjxuv736h0003p4p8vp7ofkgi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Html标签" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoBlog.github.io/2019/06/17/Html标签/" class="article-date">
  <time datetime="2019-06-17T22:33:31.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexoBlog.github.io/2019/06/17/Html标签/">细谈Html常用标签</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTML的标签很多，让人摸不着头脑。很多人纵向去学，想要实现什么功能/结构就去查询相应的标签。<br>这样确实是一种方法，然而横向比较所有标签能够帮助我们把HTML的标签织成网，加深理解。<br>本文将从标签的分类引入，介绍不同类的常用标签，加深对标签的理解和记忆。</p>
<h1 id="面向读者"><a href="#面向读者" class="headerlink" title="面向读者"></a>面向读者</h1><p>HTML新手，至少知道HTML是什么。</p>
<h1 id="从HTML的结构说起"><a href="#从HTML的结构说起" class="headerlink" title="从HTML的结构说起"></a>从HTML的结构说起</h1><p>HTML的HELLO WORLD文档可以看出其结构是非常简单的：</p>
<blockquote>
<p>&lt;!DOCTYPE html&gt; <em>文档声明</em><br><br>&lt;html&gt;<em>HTML声明</em><br><br>&lt;head&gt;<em>头部声明</em><br><br>&lt;/head&gt;<br><br>&lt;body&gt;<em>主体声明</em><br><br>&lt;/body&gt;<em>文档声明</em><br><br>&lt;/html&gt;<br></p>
</blockquote>
<h2 id="头部声明HEAD"><a href="#头部声明HEAD" class="headerlink" title="头部声明HEAD"></a>头部声明HEAD</h2><p>head内是html的头部信息，里面规定了本文档的元数据/METADATA（描述数据的数据）。<br>可以包含下列信息：</p>
<ol>
<li>HTML的METADATA类标签<br></li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
<th>常见属性</th>
</tr>
</thead>
<tbody><tr>
<td>base</td>
<td>指定默认URL</td>
<td>href target</td>
</tr>
<tr>
<td>link</td>
<td>制定外部文件，声明关系</td>
<td>href rel</td>
</tr>
<tr>
<td>noscript</td>
<td>不能执行JS时，显示的内容</td>
<td></td>
</tr>
<tr>
<td>script</td>
<td>嵌入或者链接可执行代码</td>
<td>src</td>
</tr>
<tr>
<td>style</td>
<td>样式信息，CSS</td>
<td>全局属性</td>
</tr>
<tr>
<td>title</td>
<td>网页的标题</td>
<td>只有全局属性</td>
</tr>
<tr>
<td>meta</td>
<td>其他信息</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><p>SOCIAL MEDIA内容<br><br>嵌入facebook与twitter</p>
</li>
<li><p>声明浏览器或者平台<br><br>平台： APPLE iOS， Android<br>浏览器: chrome，Firefox等</p>
</li>
<li><p>其他细类，<a href="https://github.com/joshbuchea/HEAD#twitter-card" target="_blank" rel="noopener">详细见此</a></p>
</li>
</ol>
<p>可以看出，头部信息包含该HTML的一些描述性信息，里面的内容并不会直接显示到页面上。 头部信息可包含的<br>标签是METADATA类。后面BODY里的内容会显示到页面上，也有相对应类别的标签。<br>从这里可以看出，不同的标签有着不同的功能，那么我们将有着类似功能的标签整合在一起进行对比学习，就可以达到横向学习的目的。</p>
<h1 id="标签的分类"><a href="#标签的分类" class="headerlink" title="标签的分类"></a>标签的分类</h1><p>标签可以按不同的划分规则划分，比如block标签，inline标签。 这里我们介绍<strong>内容分类</strong>。
首先，一个标签可以属于零个，一个，或者多个类容分类。 这里的内容分类类似接口的概念，<br>即一个内容分类表明了一个共性集合，只要这个标签满足了这些共性，这个标签就属于这个内容分类。<br><img src="https://mdn.mozillademos.org/files/3704/Content_categories_venn.png"><br>从内容分类横向学习标签，可以加深对每个标签的理解。<br>如图，内容分类可以分为7大类：</p>
<ul>
<li>Metadata类<br><br>功能: <ol>
<li>修饰后续文档的表现和行为。比如style</li>
<li>设置与其他文件的链接。 比如link</li>
<li>其他信息</li>
</ol>
</li>
</ul>
<p>这类标签主要就是<strong>元数据</strong>。</p>
<table>
<thead>
<tr>
<th>常见标签</th>
<th>功能</th>
<th>常用属性</th>
</tr>
</thead>
<tbody><tr>
<td>base</td>
<td>指定默认URL</td>
<td>href target</td>
</tr>
<tr>
<td>link</td>
<td>指定外部文件和本文件的关系，如指定stylesheet</td>
<td>href rel</td>
</tr>
<tr>
<td>noscript</td>
<td>不能加载JS，则显示指定内容</td>
<td></td>
</tr>
<tr>
<td>script</td>
<td>嵌入或链接可执行代码</td>
<td>src</td>
</tr>
<tr>
<td>style</td>
<td>样式信息，CSS</td>
<td>样式信息，CSS</td>
</tr>
<tr>
<td>title</td>
<td>网页的标题</td>
<td>只包含全局属性</td>
</tr>
<tr>
<td>meta</td>
<td>其他任何不属于上述标签的内容</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>FlowContent类<br><br>功能：包含文本或者嵌入元素的类，就是我们<strong>需要展示的内容</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>常见标签</th>
<th>功能</th>
<th>常用属性/TIPS</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>锚标签，用于链接其他网页、位置等，详见日后更新</td>
<td></td>
</tr>
<tr>
<td>abbr</td>
<td>缩写标签，鼠标放上后会显示全称</td>
<td>title内放入全称</td>
</tr>
<tr>
<td>adress</td>
<td>地址标签</td>
<td></td>
</tr>
<tr>
<td>bdi</td>
<td>文字方向标签，由于很多文字（如阿拉伯文，古代中文）是从右往左读的，所以我们文字也需要方向。<br>bdi是使用浏览器内置算法决定方向</td>
<td></td>
</tr>
<tr>
<td>bdo</td>
<td>同上，自己制定方向</td>
<td>dir</td>
</tr>
<tr>
<td>details &gt; summary</td>
<td>点击summary内容会展示details内容</td>
<td></td>
</tr>
<tr>
<td>embed</td>
<td>嵌入外部应用</td>
<td>type src</td>
</tr>
<tr>
<td>object</td>
<td>将外部资源嵌入浏览器</td>
<td></td>
</tr>
<tr>
<td>iframe</td>
<td>嵌入其他页面</td>
<td>embed，object与iframe区别？占坑更新</td>
</tr>
<tr>
<td>figure</td>
<td>带说明的图片img+figcaption+description</td>
<td></td>
</tr>
<tr>
<td>hgroup</td>
<td>多个标题的组，一般用在连续标题下</td>
<td></td>
</tr>
<tr>
<td>ins，del</td>
<td><ins>加入</ins>和<del>删除</del></td>
<td></td>
</tr>
<tr>
<td>kbd</td>
<td>表示键盘按键</td>
<td></td>
</tr>
<tr>
<td>map&gt;area</td>
<td>划分图片，可点击相应部分</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Sectioning content</li>
<li>Heading content</li>
<li>Pharsing content</li>
<li>embedded content</li>
<li>interactive content</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yufeicheniffy.github.io/hexoBlog.github.io/2019/06/17/Html标签/" data-id="cjxuv736e0001p4p86c9r6wme" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexoBlog.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexoBlog.github.io/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexoBlog.github.io/2019/07/08/JS数据类型/">JS数据类型</a>
          </li>
        
          <li>
            <a href="/hexoBlog.github.io/2019/06/22/Git常用命令与场景/">Git常用命令与场景</a>
          </li>
        
          <li>
            <a href="/hexoBlog.github.io/2019/06/22/http的报文和状态码/">http的报文和状态码</a>
          </li>
        
          <li>
            <a href="/hexoBlog.github.io/2019/06/17/Html标签/">细谈Html常用标签</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexoBlog.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/hexoBlog.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/hexoBlog.github.io/fancybox/jquery.fancybox.css">
  <script src="/hexoBlog.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/hexoBlog.github.io/js/script.js"></script>



  </div>
</body>
</html>